
메모이제이션 (memoization)
    : 동일한 값을 리턴하는 함수를 반복적으로 호출해야 된다면 맨 처음 값을 계산할 때 처음 값을 메모리에 저장해서 필요할 때마다 또다시 계산하지 않고 메모리에서 꺼내서 재사용하는 기법
        => 자주 필요한 값을 맨처음 계산할 때 캐싱해서 필요할 때마다 다시 계산하는 것이 아니라 캐시에서 꺼내서 사용하는 것
    
    - 함수형 컴포넌트는 함수형!
    - 함수형 컴포넌트가 렌더링이 되다? 호출된다! -> 함수 내부에 정의되어 있는 모든 변수들이 초기화 됨.
    
        function Component() {
            const value = calculate ();
            return <div>{value}</div>
        }

        function calculate() {     // 10을 반환하는 단순한 함수
            return 10;
        }

    - 대부분의 컴포넌트는 스테이트와 프롭스를 통해 수많은 렌더링을 거침. 렌더링 될 때마다 value라는 값이 호출되기 때문에 calculate도 반복적으로 계산됨.
      무거운 계산일 경우 반복적인 행위가 이뤄짐으로 비효율적.
      => 메모이제이션으로 해결 가능!

    - 처음에 계산된 결과값을 메모리에 저장해서 컴포넌트가 반복적으로 렌더링 되어도 다시 계산하는 것이 아닌, 이전에 계산된 값을 메모리에서 꺼내서 씀

        const value = useMemo(()=>{
            return calculate();
        }, [item]);

        1번째 인자? "콜백함수" => 초기 계산하여 나온 값을 저장할 함수
        2번째 인자? "의존성배열" => 배열 안의 요소의 값이 업데이트 될 때만 콜백함수를 다시 호출해서 메모이제이션 된 값을 업데이트해서 다시 메모이제이션을 해줌
                               만약 빈 배열을 넣으면 컴포넌트가 마운트 됐을 때만 값을 계산하고 이후에는 항상 메모이제이션 된 값을 꺼내서 씀
        
        ** 이것도 무분별하게 쓰면 비효율적일 수 있음
        ** 값을 재사용하는 것이기 때문에 불필요한 것들까지 저장해놓으면 성능이 낮아져서 필요한 값들만 저장해 놓아야 함!

